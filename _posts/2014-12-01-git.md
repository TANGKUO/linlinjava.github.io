---
layout: page
title: Git
category: git&github
description: 保存各种Git或GitHub相关资源
---



[TOC]

# 1. 介绍
必备技能!

# 2. Git模型

## 2.1 Git目录
一个项目只有存在Git目录才能称之Git仓库.
一个项目的`.git`目录称作Git目录(或版本库), 存储了项目所有历史和元信息.

> .git
> ├── branches/
> ├── config
> ├── description
> ├── HEAD
> ├── hooks/
> ├── index
> ├── info/
> ├── logs/
> ├── objects/
> ├── packed-refs
> └── refs/

## 2.2 Git工作区
Git工作区(working tree)则是临时存储项目文件的目录, 通常即项目当前目录. 当签出某个项目分支时, Git会从Git目录中取出Git对象在Git工作目录创建项目文件; 当提交时, Git工作目录修改产生的新文件产生Git对象保存到Git目录中.

## 2.3 Git暂存区
Git暂存区(stageing area, index)则是工作目录和项目仓库间的暂存区域, 文件提交前需要暂存在Git索引中. 但是这里却没有一个与Git目录/工作目录相似的目录, 因为Git索引其实是一个文件`.git/index`. 当工作目录文件修改时, `git add`则会把新文件创建一个对象保存在git目录中, 同时Git索引文件则更新指向给对象的索引记录.

这里Git索引其实实质上是根tree对象的暂存, 也就是说`git add`以后blob对象创建, 同时一些子tree对象创建, 而Git索引文件更新记录, 但是根tree对象和commit对象没有创建. 而`git commit`以后则把Git索引文件转化成根tree对象, 同时 commit对象创建, 并指向根tree对象.

## 2.4 Git对象
Git对象存储了项目的历史, 其实质是`.git/objects`.

所有的Git对象(object)包含三部分:类型, 大小和内容. 类型存在四种:blob, tree, commit和tag.

所有的Git对象没有名称, 或者说名称是SHA1签名, 即一个40字符的Git对象内容的SHA1哈希计算值.

可以用命令 `git cat-file $commit`查看Git对象,
或可以用命令 `git show $commit`查看Git对象.

### 2.4.1 blob对象
一个blob对象只存储一个文件内容的二进制数据, 并且没有其他属性, 甚至连文件名都没有.

### 2.4.2 tree对象
一个tree对象的内容是指向blob对象或其他tree对象的记录集合. 每个记录的结构是mode, 对象类型, SHA1签名和文件名称. tree对象一般表示内容之间的目录层次关系.

### 2.4.3 commit对象
一个commit对象的内容是:

* 一个根tree对象签名: 代表项目某一个时刻的内容
* 一个父commit对象签名: 代表项目上一时刻历史.
  当前commit对象可能没有父commit对象(此时当前commit对象则是根commit), 也可能有多个父commit对象.
* 作者: 此次修改的作者和修改日期.
* 提交者: 实际创建提交的提交者和提交日期.
* 注释: 描述此次提交.

只有存在commit对象, 才表明当前修改真正保存在Git历史中.

### 2.4.4 tag对象
一个标签对象的内容是:

* 一个对象签名
* 对象类型
* 标签名
* 标签创建者
* 注释

可以用命令 `git cat-file tag $tag`查看内容.

## 2.5 Git引用
Git引用是通过有意义的名称来避免直接使用SHA1签名, 其实质是目录`.git/refs`.

### 2.5.1 refs引用
采用update-ref命令创建一个普通的Git引用, 例如`git update-ref refs/heads/test cac0ca`. 其实这个等同于创建了一个新的分支.

### 2.5.2 HEAD引用
HEAD, 即`.git/HEAD`文件, 是一个指向当前分支的引用. 而且HEAD引用并不是一个普通的引用, 其内容并不是SHA1签名, 而是一个指向另外一个引用的引用. 通常其内容是`.git/heads`目录对应分支的文件.

> $ cat .git/HEAD
> ref: refs/heads/master

当执行分支切换命令, 如`git checkout test`时, Git则会更新HEAD文件.

> $ cat .git/HEAD
> ref: refs/heads/test

当执行提交命令, 即创建一个新的commit对象时, commit对象的父commit对象则设置成HEAD引用的引用所保存的SHA1签名, 同时虽然HEAD引用本身没有改变, 但是由于HEAD引用的引用保存了新的commit对象签名, 因此HEAD其实会自动且方便地指向了当前分支最新的commit.

### 2.5.3 tag引用
轻量级标签, 就是一个不会变化的分支，实际上它就是个指向特定提交对象的引用, 即标签引用, 其实质是`.git/tags`.

### 2.5.4 remote引用
远程引用, 存储了和远程服务器之间最后一次通信时的对象签名, 其实质是`.git/remote`目录.

和本地引用和分支不一样, remote引用和分支是不能签出(checkout)的. Git把remote引用当做标签来标记本地分支在服务器上最后状态.

# 3. 基本命令

## 3.1 配置

命令: `git config`

### 3.1.1 配置范围
1. /etc/gitconfig, 即系统级配置, 对应命令 `git config --system`
2. ~/.gitconfig 或 ~/.config/git/config, 即用户级配置, 对应命令 `git config --global`
3. ${project}/.git/config, 即仓库级配置文件, 对应命令 `git config --local`

### 3.1.2 配置属性
* user.name
* user.email
* http.proxy
```
    git config http.proxy http://127.0.0.1:1080
```
* https.proxy
* http.SSLVERIFY
```
    git config http.sslVerify false
```
* core.gitproxy

### 3.1.3 配置操作
* --edit
* --list
* --unset
* --get
* --add

## 3.2 本地仓库操作

### 3.2.1 初始化
现有项目初始化Git仓库, 命令`git init`

### 3.2.2 克隆
克隆已存在Git仓库的项目, 命令`git clone ${url} ${name}`

### 3.2.3 忽略文件
不是所有的文件都应该跟踪. 例如日志文件, 编制临时文件, 副本文件.
在项目中创建一个新的文件`.gitignore`, 列出需要忽略的文件模式.

.gitignore的格式规范:

* 所有空行或者以`#`开头的行无意义
* 标准的glob模式
* 以`/`结尾的路径视为目录
* 以`!`开头的路径视为取反

GitHub有一个[开源项目][GitHub gitignore], 保存了针对不同语言和规范的.gitignore文件.

### 3.2.4 暂存
跟踪新文件, 采用命令 `git add $file`.

暂存已跟踪文件的修改, 采用命令 `git add $file`.

手动解决冲突文件后, 采用命令 `git add $file`.

### 3.2.5 撤消修改
重置当前分支的HEAD到特定状态, 采用命令 `git reset`.

* `git reset $file`
  重置暂存区file文件的状态. 此时, 该文件的状态是工作目录已修改但是未暂存.
* `git reset --hard $commit`
  重置暂存区, 同时重置工作区.
* `git reset --soft $commit`
  既不重置暂存区, 也不重置工作区.
* `git reset --mixed $commit`
  重置暂存区, 但是不重置工作区. 这个模式是默认模式.

签出版本库或特定文件到工作区, 采用命令 `git checkout`.

* `git checkout $file`
  从暂存区签出file文件到工作区, 则工作区file文件的原本修改将被覆盖.
* `git checkout $commit $file`
  从版本库特定commit签出file文件到工作区.

### 3.2.6 移动/重命名
移动/重命名一个文件/目录/链接, 采用命令 `git mv $file_from $file_to`.

### 3.2.7 删除
从工作目录和暂存区删除文件, 采用命令 `git rm $file`

从暂存区删除文件, 但是工作目录没有删除文件, 即Git不再跟踪该文件, 采用命令 `git rm --cached $file` 或  `git rm --cached $dir`.

### 3.2.8 显示状态
显示工作目录状态, 采用命令`git status`

简介输出, 采用命令`git status -s`

输出格式为
```
    XY PATH1 -> PATH2
```

其中XY两个字母, 显示文件状态; PATH1是HEAD上文件路径; " -> PATH2"只用于PATH1对应index/worktree上的不同路径(例如文件重命名).

当merge冲突时, X和Y显示merge两边的修改状态; 当没有merge冲突时, X显示index状态, 而Y显示worktree状态; 当未跟踪文件路径时, XY是`??`; 忽略文件是默认不显示的, 如果使用`--ignored`, 则XY显示`!!`.

XY所允许的字母包括:

* ` ` = 未修改
* `M` = 已修改
* `A` = 已添加
* `D` = 已删除
* `R` = 重命名
* `C` = 复制
* `U` = 已更新但是未合并

XY字母集合包括:

|   X   |   Y   |   含义   |
|-------|-------|---------------------------|
|       | [MD]  | not updated               |
|   M   | [ MD] | updated in index          |
|   A   | [ MD] | added to index            |
|   D   | [ M]  | deleted from index        |
|   R   | [ MD] | renamed in index          |
|   C   | [ MD] | copied in index           |
| [MARC]  |     | index and work tree matches |
| [ MARC] |  M  | work tree changed since index |
| [ MARC] |  D  | deleted in work tree      |
|-------|---  --|---------------------------|
|   D   |   D   | unmerged, both deleted    |
|   A   |   U   | unmerged, added by us     |
|   U   |   D   | unmerged, deleted by them |
|   U   |   A   | unmerged, added by them   |
|   D   |   U   | unmerged, deleted by us   |
|   A   |   A   | unmerged, both added      |
|   U   |   U   | unmerged, both modified   |
|-------|-------|---------------------------|
|   ?   |   ?   | untracked                 |
|   !   |   !   | ignored                   |

### 3.2.9 查看修改
查看工作目录和暂存区之间的差异, 采用命令 `git diff`.

查看暂存区和版本库之间的差异, 采用命令 `git diff --cached` 或者 `git diff --staged`.

查看不同commit之间的差异, 采用命令 `git diff $commit1 $commit2`.

查看不同分支之间的差异, 采用命令 `git diff $branch1 $branch2`.

查看差异的统计信息, 采用 `--stat`.

### 3.2.10 提交更新
提交暂存区到仓库, 采用命令 `git commit`

* -a
  Git自动暂存所有已跟踪文件并提交.
* -m
  提交相关信息.
* --amend
  将本次提交代替当前最新提交

### 3.2.11 显示历史
显示提交历史, 命令 `git log`

* `-$num`
  显示num次的提交历史
* `-p`
  以补丁格式显示提交内容的差异.
* `--stat`
  显示提交的简略统计信息, 包括所有被修改的文件, 每个文件的删除/添加行数.
* `--pretty=$option`
  使用其他格式显示历史提交信息. 可用的选项包括oneline, short, full, fuller和format.
* `--author=$name`
  仅显示指定作者的提交
* `--committer=$name`
  仅显示指定提交者的提交

## 3.3 远程仓库操作

### 3.3.1 查看
查看已经配置的远程仓库服务器, 采用命令 `git remote`.

显示读写远程仓库的URL, 采用命令 `git remote -v`.

显示远程仓库更多信息, 采用命令 `git remote show $name`.

### 3.3.2 添加
添加一个新的远程仓库, 采用命令 `git remote add $name $url`.

克隆远程仓库时, Git会默认配置origin作为远程仓库地址的简写.

### 3.3.3 抓取
从远程仓库抓取数据, 采用命令 `git fetch $remote`.

### 3.3.4 推送
将本地数据推送到远程仓库, 采用命令 `git push $remote $branch`.

只有存在所克隆服务器的写入权限, 且之前没有人推送过, push命令才能生效.
如果远程仓库已经存在他人的推送, 那么必须先拉取他人的推送数据, 成功合并到本地仓库后, 本地数据的推送才可能成功.

### 3.3.5 移除
采用命令 `git remote rm $name`.

### 3.3.6 重命名
采用命令 `git renname $old $new`.

## 3.4 标签
标签有两种类型. 即含附注标签(annotated)和轻量级标签(lightweight).

* 轻量级标签是一个不会变化的分支，实际上它就是个指向特定提交对象的引用, 即标签引用, 其实质是`.git/tags`.
创建轻量级标签, 采用命令 `git update-ref`命令, 例如`git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d`.
* 含附注标签是存储在仓库中的一个tag对象, 即标签对象, 其实质是`.git/objects`里的一个tag对象.
* 通常建议使用含附注标签.

### 3.4.1 创建
创建轻量级标签, 采用命令 `git tag $name`.

创建含附注标签, 采用命令 `git tag -a $name -m $message`.

对过去的提交创建标签, 采用命令 `git tag -a $name $commit`

### 3.4.2 查看
查看已创建的标签, 采用命令 `git tag`.
查看某个标签, 采用命令 `git show $tag`.

### 3.4.3 共享
默认情况下, push命令并不会自动传送标签到远程仓库上, 因此需要手动推送标签到远程仓库, 采用命令 `git push $remote $tag`, 例如`git push origin v1.0`.
而采用命令`git push $remote --tags`可以把所有不在远程仓库上的标签全部推送过去.

### 3.4.4 签出
Git中的标签并不能真的签出, 与其他版本系统意义并不完全一致.

如果需要工作目录和仓库中特定标签版本相一致, 采用命令 `git checkout -b $branch $tag`. 该命令实质: 创建一个新的分支, 同时该分支的最新提交是标签所指向的提交, 因此

# 4. 分支模型
Git分支, 本质上是指向Git commit对象的可变引用. Git的默认分支名字是master, 在每次提交以后master会自动向前移动, 指向最新的commit对象.

## 4.1 本地分支操作

### 4.1.1 分支创建
采用命令 `git branch $branch`.

### 4.1.2 分支切换
切换到一个已创建的分支, 采用命令 `git checkout $branch`.

签出命令的实质是两个工作:

* HEAD指向新分支
* 工作目录修改成新分支指向的快照内容.

创建并立即切换到新分支, 采用命令 `git checkout -b $branch`.

### 4.1.3 分支删除
删除一个已经创建的分支, 采用命令 `git checkout -d $branch`.

### 4.1.4 分支合并
假设当前分支是master, 存在另外一个分支test, 那么合并test分支的修改到当前master分支, 采用命令`git merge test`.

合并过程会存在两种情况:

1. 直接祖先
  如果master指向的commit对象是test指向的commit对象的直接祖先, 那么master重定向指向test指向的commit对象, 即完成了合并操作. 这次非常迅速简单的合并过程, 称作快进(fast-forward).
2. 共同祖先
  如果master指向的commit对象和test指向的commit对象之间并不是直接祖先关系, 但是两者之间会存在一个共同祖先的commit对象, 那么Git将会进行简单的三方合并操作. 即创建一个新的commit对象, 其父对象存在两个, 分别是原master指向的commit对象和原test对象指向的commit对象, 然后更新当前master指向这个新的commit对象.

  然而, Git这里必须先做一个检测过程, 即确认是否两个分支对同一个文件的同一处做了不同的修改. 如果不存在, 那么Git就会继续进行三方合并操作. 如果存在不同的修改, 那么Git将放弃做合并操作, 即存在合并冲突.
  
  存在合并冲突时, Git将要求合并者来解决产生的文件修改冲突问题. 首先,  存在合并冲突的文件会以未合并状态标识处理; 其次, 合并者需要手动解决冲突文件中的冲突部分; 然后, 合并者使用`git add`命令将文件状态更新为冲突已解决; 最后, 合并这使用`git commit`命令来完成合并提交.

### 4.1.5 分支查询
查询当前的分支情况, 采用命令 `git branch`.

* git branch -v
  查看每一个分支的最后一次提交情况
* git branch --merged
  查看哪些分支已经合并到当前分支
* git branch --no-merged
  查看哪些分支没有合并到当前分支

### 4.1.6 分支开发流

1. 长期分支
  * master分支
  * develop分支
  * topic分支
2. 特性分支
  特性分支是一种短期分支, 用于实现单一特性或其相关工作.
3. 远程分支
  远程分支是远程仓库的分支状态的引用. 在本地不能移动远程分支, 而只有在进行为了通信操作时, 这些分支才会自动移动. 命名方式是`$remote/$branch`.

### 4.1.7 本地分支推送
本地仓库分支推送到有写入权限的远程仓库, 采用命令 `git push $remote $branch`.

假设本地分支test, 远程仓库origin, 远程分支test, 那么使用命令 `git push origin test`.
假设本地分支test, 远程仓库origin, 远程分支demo, 那么使用命令 `git push origin test:demo`.

## 4.2 远程分支操作

### 4.2.1 远程分支拉取
仅仅从远程仓库拉取本地仓库分支没有的数据, 同时不修改工作目录, 也不合并, 采用命令 `git fetch`.

而查找当前分支所跟踪的远程仓库分支, 从远程仓库拉取本地仓库分支没有的数据, 同时合并到当前分支, 采用命令`git pull`. 大多数情况下, `git pull`的含义等同于`git fetch`和`git merge`.

### 4.2.2 远程分支删除
删除远程仓库的远程分支, 采用命令 `git push $remote --delete $branch`.

# 中英文对照

# 参考

[Git](http://www.git-scm.com/)

[Git Community Book中文版](http://gitbook.liuhui998.com/)

[Pro Git中文版](http://www.git-scm.com/book/zh/v2)

[GitHub gitignore](https://github.com/github/gitignore)

